<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Saving Results</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Saving Results</h1>

<p>Unsurprisingly, you may want to save your results to your hard disk in case of power outages or random system crashes to allow restarting at the interrupted location, save more complete versions of the analysis results in case you want to inspect the complete simulation results at a later time, store/restore the R seeds for debugging and replication purposes, and so on. This document demonstrates various ways in which <code>SimDesign</code> saves output to hard disks. </p>

<p>As usual, define the functions of interest. </p>

<pre><code class="r">library(SimDesign)
# SimFunctions()

Design &lt;- data.frame(N = c(10,20,30))
</code></pre>

<pre><code class="r">Generate &lt;- function(condition, fixed_objects = NULL) {
    dat &lt;- rnorm(condition$N)    
    dat
}

Analyse &lt;- function(condition, dat, fixed_objects = NULL) {
    ret &lt;- c(p = t.test(dat)$p.value)
    ret
}

Summarise &lt;- function(condition, results, fixed_objects = NULL) {
    ret &lt;- EDR(results, alpha = .05)
    ret
}
</code></pre>

<p>This is a very simple simulation that takes very little time to complete, however it will be used to show the basic saving concepts supported in <code>SimDesign</code>. Note that more detailed information is located in the <code>runSimulation</code> documentation.</p>

<h2>Option: <code>save = TRUE</code></h2>

<p>The <code>save</code> flag triggers whether temporary results should be saved to the hard-disk in case of power outages and crashes. When this flag is used results can easily be restored automatically and the simulation can continue where it left off after the hardware problems have been dealt with. In fact, no modifications in the code required because <code>runSimulation()</code> will automatically detect temporary files to resume from (so long as they are resumed from the same computer node; otherwise, see the <code>save_details</code> list).</p>

<p>As a simple example, say that in the \(N=30\) condition something went terribly wrong and the simulation crashed. However, the first two design conditions are perfectly fine. The <code>save</code> flag is very helpful here because the state is not lost and the results are still useful. Finally, supplying a <code>filename</code> argument will safely save the aggregate simulation results to the hard-drive for future reference; however, this won&#39;t be called until the simulation is complete.</p>

<pre><code class="r">Analyse &lt;- function(condition, dat, fixed_objects = NULL) {
    if(condition$N == 30) stop(&#39;Danger Will Robinson!&#39;)
    ret &lt;- c(p = t.test(dat)$p.value)
    ret
}

result &lt;- runSimulation(Design, replications = 1000, save=TRUE, filename=&#39;my-simple-sim&#39;,
                       generate=Generate, analyse=Analyse, summarise=Summarise)
</code></pre>

<pre><code>## 
## 
Design row: 1/3;   Started: Fri Jan 18 09:44:18 2019;   Total elapsed time: 0.00s 
## 
## 
Design row: 2/3;   Started: Fri Jan 18 09:44:18 2019;   Total elapsed time: 0.34s 
## 
## 
Design row: 3/3;   Started: Fri Jan 18 09:44:18 2019;   Total elapsed time: 0.62s
</code></pre>

<p>Check that temporary file exists. </p>

<pre><code class="r">files &lt;- dir()
files[grepl(&#39;SIMDESIGN&#39;, files)]
</code></pre>

<pre><code>## [1] &quot;SIMDESIGN-TEMPFILE_phil-ThinkPad-X1-Carbon-3rd.rds&quot;
## [2] &quot;SIMDESIGN_CRASHFILE_SEEDS.rds&quot;
</code></pre>

<p>Notice here that the simulation stopped at 67% because the third design condition threw too many consecutive errors (this is a built-in fail-safe in <code>SimDesign</code>). However, after we fix this portion of the code the simulation can be restarted at the previous state and continue on as normal. Therefore, no time is lost.</p>

<pre><code class="r">Analyse &lt;- function(condition, dat, fixed_objects = NULL) {
    ret &lt;- c(p = t.test(dat)$p.value)
    ret
}

result &lt;- runSimulation(Design, replications = 1000, save=TRUE, filename=&#39;my-simple-sim&#39;,
                       generate=Generate, analyse=Analyse, summarise=Summarise)
</code></pre>

<pre><code>## 
## 
Design row: 3/3;   Started: Fri Jan 18 09:44:18 2019;   Total elapsed time: 0.62s
</code></pre>

<p>Check which files exist. </p>

<pre><code class="r">files &lt;- dir()
files[grepl(&#39;SIMDESIGN&#39;, files)]
</code></pre>

<pre><code>## [1] &quot;SIMDESIGN_CRASHFILE_SEEDS.rds&quot;
</code></pre>

<pre><code class="r">files[grepl(&#39;my-simp&#39;, files)]
</code></pre>

<pre><code>## [1] &quot;my-simple-sim.rds&quot;
</code></pre>

<p>Notice that when complete, the temporary file is removed from the hard-drive.</p>

<h2>Option: <code>save_results = TRUE</code></h2>

<p>Continuing on, the <code>save_results</code> argument will output the elements which are passed to <code>Summarise()</code> to separate <code>.rds</code> files containing all the analysis results. Note that when using <code>save_results</code> the <code>save</code> flag is automatically set to <code>TRUE</code> to ensure that the simulation state is correctly tracked.</p>

<pre><code class="r">results &lt;- runSimulation(Design, replications = 1000, save_results=TRUE,
              generate=Generate, analyse=Analyse, summarise=Summarise)
</code></pre>

<pre><code>## 
## 
Design row: 1/3;   Started: Fri Jan 18 09:44:18 2019;   Total elapsed time: 0.00s 
## 
## 
Design row: 2/3;   Started: Fri Jan 18 09:44:19 2019;   Total elapsed time: 0.28s 
## 
## 
Design row: 3/3;   Started: Fri Jan 18 09:44:19 2019;   Total elapsed time: 0.56s
</code></pre>

<pre><code class="r">dir &lt;- dir()
directory &lt;- dir[grepl(&#39;SimDesign-results&#39;, dir)]
dir(directory)
</code></pre>

<pre><code>## [1] &quot;results-row-1.rds&quot; &quot;results-row-2.rds&quot; &quot;results-row-3.rds&quot;
</code></pre>

<p>Here we can see that three <code>.rds</code> files have been saved to the folder with the computer node name and a prefixed <code>&#39;SimDesign-results&#39;</code> character string. Each <code>.rds</code> file contains the respective simulation results (including errors and warnings), which can be read in directly with <code>readRDS()</code></p>

<pre><code class="r">row1 &lt;- readRDS(paste0(directory, &#39;/results-row-1.rds&#39;))
str(row1)
</code></pre>

<pre><code>## List of 5
##  $ condition  :&#39;data.frame&#39;: 1 obs. of  3 variables:
##   ..$ ID         : int 1
##   ..$ REPLICATION: int 0
##   ..$ N          : num 10
##  $ results    : num [1:1000, 1] 0.6354 0.0207 0.3661 0.3016 0.7379 ...
##   ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. ..$ : NULL
##   .. ..$ : chr &quot;p&quot;
##  $ errors     : &#39;table&#39; int[0 (1d)] 
##   ..- attr(*, &quot;dimnames&quot;)=List of 1
##   .. ..$ : NULL
##  $ error_seeds: int[0 , 1:626] 
##  $ warnings   : &#39;table&#39; int[0 (1d)] 
##   ..- attr(*, &quot;dimnames&quot;)=List of 1
##   .. ..$ warnings: NULL
</code></pre>

<pre><code class="r">row1$condition
</code></pre>

<pre><code>##   ID REPLICATION  N
## 1  1           0 10
</code></pre>

<pre><code class="r">head(row1$results)
</code></pre>

<pre><code>##            p
## [1,] 0.63541
## [2,] 0.02065
## [3,] 0.36612
## [4,] 0.30162
## [5,] 0.73788
## [6,] 0.72406
</code></pre>

<p>or, equivalently, with the <code>SimResults()</code> function</p>

<pre><code class="r">row1 &lt;- SimResults(results, 1)
str(row1)
</code></pre>

<pre><code>## List of 5
##  $ condition  :&#39;data.frame&#39;: 1 obs. of  3 variables:
##   ..$ ID         : int 1
##   ..$ REPLICATION: int 0
##   ..$ N          : num 10
##  $ results    : num [1:1000, 1] 0.6354 0.0207 0.3661 0.3016 0.7379 ...
##   ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. ..$ : NULL
##   .. ..$ : chr &quot;p&quot;
##  $ errors     : &#39;table&#39; int[0 (1d)] 
##   ..- attr(*, &quot;dimnames&quot;)=List of 1
##   .. ..$ : NULL
##  $ error_seeds: int[0 , 1:626] 
##  $ warnings   : &#39;table&#39; int[0 (1d)] 
##   ..- attr(*, &quot;dimnames&quot;)=List of 1
##   .. ..$ warnings: NULL
</code></pre>

<p>The <code>SimResults()</code> function has the added benefit that it can read in all simulation 
results at once, or simply hand pick which ones should be inspected. For example,
here is how all the saved results can be inspected:</p>

<pre><code class="r">input &lt;- SimResults(results)
str(input)
</code></pre>

<pre><code>## List of 3
##  $ :List of 5
##   ..$ condition  :&#39;data.frame&#39;:  1 obs. of  3 variables:
##   .. ..$ ID         : int 1
##   .. ..$ REPLICATION: int 0
##   .. ..$ N          : num 10
##   ..$ results    : num [1:1000, 1] 0.6354 0.0207 0.3661 0.3016 0.7379 ...
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. .. ..$ : NULL
##   .. .. ..$ : chr &quot;p&quot;
##   ..$ errors     : &#39;table&#39; int[0 (1d)] 
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 1
##   .. .. ..$ : NULL
##   ..$ error_seeds: int[0 , 1:626] 
##   ..$ warnings   : &#39;table&#39; int[0 (1d)] 
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 1
##   .. .. ..$ warnings: NULL
##  $ :List of 5
##   ..$ condition  :&#39;data.frame&#39;:  1 obs. of  3 variables:
##   .. ..$ ID         : int 2
##   .. ..$ REPLICATION: int 0
##   .. ..$ N          : num 20
##   ..$ results    : num [1:1000, 1] 0.318 0.14 0.253 0.235 0.12 ...
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. .. ..$ : NULL
##   .. .. ..$ : chr &quot;p&quot;
##   ..$ errors     : &#39;table&#39; int[0 (1d)] 
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 1
##   .. .. ..$ : NULL
##   ..$ error_seeds: int[0 , 1:626] 
##   ..$ warnings   : &#39;table&#39; int[0 (1d)] 
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 1
##   .. .. ..$ warnings: NULL
##  $ :List of 5
##   ..$ condition  :&#39;data.frame&#39;:  1 obs. of  3 variables:
##   .. ..$ ID         : int 3
##   .. ..$ REPLICATION: int 0
##   .. ..$ N          : num 30
##   ..$ results    : num [1:1000, 1] 0.717 0.103 0.355 0.973 0.921 ...
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. .. ..$ : NULL
##   .. .. ..$ : chr &quot;p&quot;
##   ..$ errors     : &#39;table&#39; int[0 (1d)] 
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 1
##   .. .. ..$ : NULL
##   ..$ error_seeds: int[0 , 1:626] 
##   ..$ warnings   : &#39;table&#39; int[0 (1d)] 
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 1
##   .. .. ..$ warnings: NULL
</code></pre>

<p>Should the need arise to remove the results directory then the <code>SimClean()</code> function is the easiest way to remove unwanted files and directories. </p>

<pre><code class="r">SimClean(results = TRUE)
</code></pre>

<h2>Option: <code>store_results = TRUE</code></h2>

<p>Similar to <code>save_results = TRUE</code>, though less recommended for RAM related reasons (if the number of replications/<code>design</code> conditions is too large then the R session may run out of memory as the simulation progresses), users can pass <code>store_results = TRUE</code> to store the complete simulation results in the returned object. </p>

<p>After the simulation is complete, these results can be extracted using the <code>extract_results()</code> function. For example,</p>

<pre><code class="r">results &lt;- runSimulation(Design, replications = 3, store_results=TRUE,
              generate=Generate, analyse=Analyse, summarise=Summarise)
</code></pre>

<pre><code>## 
## 
Design row: 1/3;   Started: Fri Jan 18 09:44:19 2019;   Total elapsed time: 0.00s 
## 
## 
Design row: 2/3;   Started: Fri Jan 18 09:44:19 2019;   Total elapsed time: 0.00s 
## 
## 
Design row: 3/3;   Started: Fri Jan 18 09:44:19 2019;   Total elapsed time: 0.01s
</code></pre>

<pre><code class="r">list_results &lt;- extract_results(results)
list_results
</code></pre>

<pre><code>## $`N=10`
##           p
## [1,] 0.3498
## [2,] 0.9933
## [3,] 0.6909
## 
## $`N=20`
##           p
## [1,] 0.9114
## [2,] 0.9628
## [3,] 0.9330
## 
## $`N=30`
##           p
## [1,] 0.1607
## [2,] 0.6625
## [3,] 0.2077
</code></pre>

<h1>My recommendations</h1>

<p>My general recommendation when running simulations is to use the <code>save = TRUE</code> flag when your simulation is finally ready for run time (particularly for simulations which take a long time to finish), and to supply a <code>filename = &#39;some_simulation_name&#39;</code>. As the aggregation of the simulation results is often what you are interested in then this approach will ensure that the results are stored in a succinct manner for later analyses. </p>

<p>As well, passing <code>save_results = TRUE</code> will save all the results from the input <code>Analysis()</code> function which was passed to <code>Summarise()</code>, as well as save a final file to your hard-drive (but with the built-in safety feature that it will never over-write previously saved files). Hence, you&#39;ll be able to inspect all the elements manually if the need were to arise (e.g., to inspect <code>ECR(res1, alpha = .01)</code> instead of the <code>ECR(results, alpha = .05)</code> which may have only been used in the <code>Summarise()</code> function). However, do this <strong>only</strong> if your hard-drive can store all of the analysis results; if you are not careful, you could easily fill up your entire drive with the analysis results alone.</p>

<p>Finally, if you are worried about reproducibility, particularly during the debugging states, then the <code>seed</code> and <code>save_seeds</code> are the arguments you should utilize. <code>seed</code> sets the global seed for each design row, while <code>save_seed</code> writes the <code>.Random.seed</code> state to the hard-disk for complete reproducibility within each design condition (note that all seeds can be saved in parallel or when running simulations on single cores). If <code>save_seed</code> were used then the exact simulation state can be reloaded to the generated data by passing the specific saved seed file to <code>load_seed</code>. This also makes tracking down hard-to-find bugs within each design condition much easier. </p>

</body>

</html>
